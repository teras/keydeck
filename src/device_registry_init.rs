// SPDX-License-Identifier: GPL-3.0-or-later
// Copyright (C) 2025 Panayotis Katsaloulis

use crate::{error_log, info_log, verbose_log};
use std::fs;
use std::path::{Path, PathBuf};

// Include the embedded device definitions generated by build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_devices.rs"));

/// Get the user's device directory path
fn get_user_devices_dir() -> Result<PathBuf, String> {
    let home = std::env::var("HOME")
        .map_err(|_| "HOME environment variable not set".to_string())?;

    Ok(PathBuf::from(home).join(".config/keydeck/devices"))
}

/// Ensure a directory exists, creating it if necessary
fn ensure_directory(path: &Path) -> Result<(), String> {
    if !path.exists() {
        fs::create_dir_all(path)
            .map_err(|e| format!("Failed to create directory '{}': {}", path.display(), e))?;
        verbose_log!("Created directory: {}", path.display());
    }
    Ok(())
}

/// Get the system device directory path
fn get_system_devices_dir() -> PathBuf {
    PathBuf::from("/usr/share/keydeck/devices")
}

/// Extract embedded device JSON files to the user's config directory
/// Only creates files that don't exist in either system or user paths
fn extract_embedded_devices() -> Result<(), String> {
    let system_dir = get_system_devices_dir();
    let user_dir = get_user_devices_dir()?;

    // Ensure the user devices directory exists
    ensure_directory(&user_dir)?;

    let mut created_count = 0;
    let mut skipped_system = 0;
    let mut skipped_user = 0;

    for (filename, content) in EMBEDDED_DEVICES {
        let system_path = system_dir.join(filename);
        let user_path = user_dir.join(filename);

        // Check system path first (higher priority)
        if system_path.exists() {
            verbose_log!("Device file exists in system path, skipping: {}", filename);
            skipped_system += 1;
        }
        // Then check user path
        else if user_path.exists() {
            verbose_log!("Device file exists in user path, skipping: {}", filename);
            skipped_user += 1;
        }
        // If neither exists, create in user path
        else {
            fs::write(&user_path, content)
                .map_err(|e| format!("Failed to write device file '{}': {}", filename, e))?;
            info_log!("Installing device file: {}", filename);
            created_count += 1;
        }
    }

    if created_count > 0 {
        info_log!(
            "Installed {} device definition(s) to {}",
            created_count,
            user_dir.display()
        );
    }
    if skipped_system > 0 {
        verbose_log!("Skipped {} device(s) found in system path", skipped_system);
    }
    if skipped_user > 0 {
        verbose_log!("Skipped {} device(s) found in user path", skipped_user);
    }

    Ok(())
}

/// Initialize device registry: extract embedded files and return search paths
/// This should be called before device enumeration
pub fn initialize_device_registry() -> Result<Vec<String>, String> {
    // First, extract embedded device files to user directory
    if let Err(e) = extract_embedded_devices() {
        error_log!(
            "Warning: Failed to extract embedded device files: {}",
            e
        );
        error_log!("Device registry will only search system paths");
    }

    // Return search paths in priority order (system first, then user overrides)
    let paths = vec![
        "/usr/share/keydeck/devices".to_string(),
        format!(
            "{}/.config/keydeck/devices",
            std::env::var("HOME").unwrap_or_default()
        ),
    ];

    verbose_log!("Device registry search paths:");
    for (i, path) in paths.iter().enumerate() {
        verbose_log!("  [{}] {}", i, path);
    }

    Ok(paths)
}
